/**
 * tif tiles are .tifs (shocking, I know)
 * Seams per tile are NOT corrected
 * Generated by external services such as a map server
 */
// @ts-ignore
import { fromArrayBuffer } from '../secondary/geotiff/geotiff'

export default function TifParser(
    tilePath: string,
    layerObj?: any,
    xyz?: any,
    tileResolution?: number,
    numberOfVertices?: number
): Promise<number[]> {
    return new Promise((resolve, reject) => {
        fetch(tilePath)
            .then((resp) => resp.arrayBuffer())
            .then((buffer) => {
                fromArrayBuffer(buffer).then((tif) => {
                    tif.readRasters()
                        .then((rasters) => {
                            let heightArr = rasters[0]

                            // correctSeams
                            if (
                                layerObj &&
                                layerObj.demFormatOptions &&
                                layerObj.demFormatOptions.correctSeams === true
                            ) {
                                // Since we buffer 1px out on each each we're going to assume the tileRes is smaller
                                // if tileResolution is 32x31, it goes down to 31x31, buffered out all
                                // directions and queried as 33x33, then interpolated on with a simple 2x2 kernel to 32x32
                                tileResolution--

                                const tr2 = tileResolution + 2
                                const heightArrInterp = []
                                for (let y = 0; y < tileResolution + 1; y++) {
                                    for (
                                        let x = 0;
                                        x < tileResolution + 1;
                                        x++
                                    ) {
                                        // It just takes the four surrounding and averages them
                                        // Nothing fancy at the ends of the lines or columns because they're already one over
                                        heightArrInterp.push(
                                            (heightArr[y * tr2 + x] +
                                                heightArr[y * tr2 + x + 1] +
                                                heightArr[(y + 1) * tr2 + x] +
                                                heightArr[
                                                    (y + 1) * tr2 + x + 1
                                                ]) /
                                                4
                                        )
                                    }
                                }
                                heightArr = heightArrInterp
                            }
                            resolve(heightArr)
                        })
                        .catch(() => {
                            reject()
                        })
                })
            })
            .catch(() => {
                reject()
            })
    })
}
