import { Projection, TiledWorld, Events } from './core';
import { Scene, Object3D, Vector3, Mesh, TextureLoader, Raycaster } from 'three';
import Layers from './layers';
import Controls from './controls';
import { Options, XYZ, LatLng, LatLngElev, LatLngZ } from './generalTypes';
interface Private {
    containerId: string;
    container: HTMLElement;
    sceneContainer: HTMLElement;
    wasInitialized: boolean;
    rendererWrapper: any;
    renderer: any;
    cameras: any;
    tiledWorld: TiledWorld;
    events: Events;
    maxZoom: number;
    minNativeZoom: number;
    loader: TextureLoader;
    raycaster: Raycaster;
    updateEveryNthRender: number;
    counters: {
        update: number;
        frame: number;
    };
    lastCameraWasFirst: boolean;
    firstUpdate: boolean;
    firstLoad: boolean;
    loadingScreen: any;
    renderOnlyWhenOpen: boolean;
    zCutOff: number;
    firstViewOverride: any;
    mouseIsInScene: boolean;
    marsRadius: number;
}
export default class LithoSphere {
    _: Private;
    options: Options;
    projection: Projection;
    layers: Layers;
    controls: Controls;
    addLayer: Function;
    removeLayer: Function;
    toggleLayer: Function;
    setLayerOpacity: Function;
    setLayerFilterEffect: Function;
    setLayerSpecificOptions: Function;
    getLayerByName: Function;
    hasLayer: Function;
    addControl: Function;
    removeControl: Function;
    scene: Scene;
    scenesLOD: Scene[];
    sceneBack: Scene;
    sceneFront: Scene;
    planetCenter: Vector3;
    planet: Object3D;
    planetsLOD: Object3D[];
    starsphere: Mesh;
    atmosphere: Mesh;
    zoom: number;
    trueZoom: number;
    mouse: LatLngElev;
    exaggeration: number;
    frontGroup: Object3D;
    constructor(containerId: string, options: Options);
    _init(): boolean;
    _animate: () => void;
    _render(): void;
    _update(): void;
    _onFirstLoad: () => void;
    setCenter: (latLngZoom: LatLngZ, ignoreZoom?: boolean, accountForHeight?: boolean) => boolean;
    getCenterXYZ: (raycasted?: boolean) => Vector3;
    getCenter: (raycasted?: boolean) => LatLng;
    getCenterElevation: () => number;
    getCenterElevationRaw: () => number;
    getElevationAtLngLat: (lng: number, lat: number) => number;
    getCenterTile: () => XYZ;
    getCameras: () => {
        camera: any;
        isFirstPerson: any;
        firstPerson: any;
        orbit: any;
    };
    _setInitialCameraPositionTarget: () => void;
    setCameraPositionTarget: (position?: XYZ, target?: XYZ) => void;
    getContainer: () => HTMLElement;
    invalidateSize: () => void;
}
export {};
